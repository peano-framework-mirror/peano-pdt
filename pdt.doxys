/**

\mainpage "Peano Development Toolkit (PDT)"
  

The pdt is the tool coming along with Peano to generate all glue code and 
the empty class frames to be filled with data. A pdt specification file always 
has the same structure:

- Header. With component name and namespace specifier. 
- Vertex. Basically a link to a DaStGen definition file. It also can define 
  some default getters and setters.
- Cell and State. They are referencing to a DaStGen definition file.  
- Mappings.
- Adapters.

<h1>Re-building the PDT</h1>

Usually, it should not be necessary to rebuild the PDT. However, if you have 
to, type in 

\code
ant clean
ant createParser
ant compile
ant dist 
\endcode

which gives you both a new jar and the corresponding zip with sources. Usually, 
you have to do this if and only if you have an older Java version that is not 
supported by the one online. You might also think about cross-compiling in 
this case. To cross-compile type in 

\code
update-alternatives --config java

  Auswahl      Pfad                                            Priorit√§t Status
------------------------------------------------------------
* 0            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      automatischer Modus
  1            /usr/lib/jvm/java-6-openjdk-amd64/jre/bin/java   1061      manueller Modus
  2            /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java   1071      manueller Modus
  3            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      manueller Modus
\endcode  

as superuser and select another Java version.



<h1> Vertex specification </h1>

The vertex specification first links to a DaStGen definition file. pdt hands 
over this one to DaStGen and translates it into plain C++ code. After the 
definition, you can specify a couple of getter:

\code
  vertex:
  dastgen-file: Vertex.def
  read scalar(int):  MyVariable
  read vector(double):  MyVariable
  write stencil(double):   MyVariable
\endcode

Due to a read/write specifier , pdt generates a static operation that basically 
takes all adjacent vertices and extracts the specified variable (MyVariable 
above) into one big array: If there's a scalar MyVariableA defined on each 
vertex and you write down 
\code
  read scalar: MyVariableA
\endcode
this results in a code that takes @f$ 2^d @f$ vertices, and extracts all 
MyVariableA into one big vector of length @f$ 2^d @f$. If MyVariableA were a 
stencil, you would have to use stencil instead of scalar and the result would 
be a vector of size @f$ 2^d \cdot 3^d @f$. 


||  Keyword                    ||  Data cardinality of vertex ||  Data cardinality of read result || Datatype
||  scalar(double)             |              1               |        2^d                        |  double
||  vector(double)             |              d               |        2^d * d                    |  double
||  vector2PowD(double)        |              2^d             |        2^d * 2^d                  |  double
||  stencil(double)            |              3^d             |        2^d * 3^d                  |  double
||  intergrid-operator(double) |              5^d             |        2^d * 5^d                  |  double
||  scalar(int)                |              1               |        2^d                        |  int
||  vector(int)                |              d               |        2^d * d                    |  int
||  vector2PowD(int)           |              2^d             |        2^d * 2^d                  |  int
||  stencil(int)               |              3^d             |        2^d * 3^d                  |  int
||  intergrid-operator(int)    |              5^d             |        2^d * 5^d                  |  int


*/

